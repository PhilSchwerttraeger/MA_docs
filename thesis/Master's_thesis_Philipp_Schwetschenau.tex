\documentclass[twoside, openright, 12pt]{book}
\sloppy

% Preamble
\input{other/definitions}

\begin{document}

%
% Titelseite
\begin{titlepage}
\newlength{\detailwidth}
\newlength{\detaildescriptionwidth}
\settowidth{\detailwidth}{Eingereicht:~~ Prof. Dr.-Ing. habil. Winfried E. Kühnhauser}
\settowidth{\detaildescriptionwidth}{Studies:~~} 
\begin{center}

\vfill {
	\includegraphics[width=6cm]{logo-tu-ilmenau.jpg}
	\vspace{8ex}
}

\begin{normalsize}Technische Universität Ilmenau \\
Fakultät für Informatik und Automatisierung \\
Institut für Praktische Informatik und Medieninformatik \\
Fachgebiet für Verteilte Systeme und Betriebssysteme        
\end{normalsize}


\vfill {\large
	Master's thesis\\ \vspace{2ex}
	\LARGE \textbf{Graphical Specification Language \\for the Entity-Labeling Aspect} \\ \vspace{2.5ex} 
	\normalsize Submitted by: \\
	\Large Philipp Schwetschenau \\ \vspace{3ex} 
}
\vfill \parbox{\detailwidth}{
	\makebox[\detaildescriptionwidth][r]{Supervisor:~~} Prof. Dr.-Ing. habil. Winfried E. Kühnhauser \\
	\makebox[\detaildescriptionwidth][r]{Supervisor:~~} Dipl.-Inf. Peter Amthor \\
	\vspace{2ex} \\
	\makebox[\detaildescriptionwidth][r]{Studies:~~} Computer science\\  
	\makebox[\detaildescriptionwidth][r]{Matriculation no.:~~} 46756  
	\vspace{2ex} \\
	\makebox[\detaildescriptionwidth][r]{Submission:~~} Ilmenau, 29. November 2018 (planned)
}
\vspace*{\fill}
\end{center}
\end{titlepage}

\mbox{}
\thispagestyle{empty}
\cleardoublepage

% Gliederung
\pagenumbering{roman}
\setcounter{page}{1}
\tableofcontents

% Abbildungsverzeichnis
\cleardoublepage
\listoffigures
\tocentry{List of figures}

%\listoflisting
%\tocentry{\listingname}

%
% Citing

% Author 1 et al. [1234]
%\cite{Harrison75a}

% Author 1, Author 2, Author 3 [1234]
%\cite*{Harrison75a}

% [Author 1 et al. 1234]
%\citep{Harrison75a}

% [Author 1, Author 2, Author 3 1234]
%\citep*{Harrison75a}



% Inhalts-Teil
\cleardoublepage
\pagenumbering{arabic}
\chapter{Introduction}
\label{introduction}

\section{Domain} 
\label{domain}
With the increasing number of IT systems, securing these systems became an obvious and important issue.
For this purpose many security models and model families were developed for a wide field of application domains over the last years.

Formal security models offer possibilities to analyze them concerning security properties.
However, because quantity and variety of these models grow just as much as their relevance for security-critical applications the model-based security engineering process became more complex and therefore error-prone to human deviations.

\citet*{Amthor18} proposed a new approach called Aspect-oriented Security Engineering (AOSE) which claims to close semantic gaps between steps in the security engineering process (requirements, informal policy, formal model) to reduce the potential impact of human errors.
This approach roughly adopts the idea of the aspect-oriented programming paradigm.
It tailors all steps to aspects, which are non-functional requirements of the engineering process like determining requirements of policy semantics or analyzing certain security goals.
There are two major classes for aspects regarding AOSE: related to policy semantics and to policy analysis.

One possible aspect of the former is the Entity Labeling Aspect (EL).
It is designed to formally specify policy semantics typically found in operating systems and middleware systems.
Therefore it bridges the gap and supports the transformation between informal policy and formal model.
EL classifies model components into six semantic categories.
The notation is on a mathematical basis and uses concepts like sets, assignments or constraints.



\section{Motivation} 
\label{motivation}
The goal of reducing the impact of human errors by closing semantic gaps as much as possible with the help of AOSE/EL requires handling another formal notation, which is, in this case, EL itself and its classification into the six semantic categories.
To support working with this approach, especially for the communication between different groups of people involved like model engineers, security architects, software developers or future administrators, who have to cooperate and coordinate and all have different levels of experience, \citet*{Amthor18} considers a graphical representation to be helpful to enhance the transition between informal and formalized notation.

\citet*{Amthor18} already uses visual representations to illustrate examples.
However, the representations are not described in detail as well as they are inconsistent and ambiguous regarding several parts of the formalization (e.g.\ arrows can have several meanings and there is no way to specify functions with multiple input parameters).
So these visualizations are appropriate to underline and support the engineering of an already formalized policy after EL-based model engineering, but are not suitable for independent modeling on a stand-alone level, because they are not equivalent to their formalized mathematical counterpart.

There are two types of visualization \cite{Amthor18} uses, which have different levels of abstraction: 
One is based on the actual model components and visualizes them and their relationships.
The other one is based on a higher level of abstraction and visualizes the EL with its structure of semantic categories and their relationships.

There are other visual notations like UML or ERD, which have in common that they are tailored to particular needs in special application domains, so they can not be applied here, but may give inspiration on how to model certain semantics and relationships.

Eventually to be able to independently and visually model and work on EL-based policies there is need for an unambiguous formal graphical specification language.



\section{Goal}
\label{goal}
The main goal is to develop a graphical specification language for EL-based security polices.
This should focus on clean and unambiguous semantics of the language.

The use of the language should be as simple as possible and as comprehensive as needed.
Therefore its appearance and elements should be clear and well-structured.
A selection of appropriate symbols and geometrical shapes for their equivalent model counterparts has to be made regarding an intuitive understanding and workflow.
This selection should not be designed contradictory or conflicting to already established notations, especially those, which may be used in the context of security engineering.

It should be evaluated how feasible and reasonable it is to develop equivalent counterparts for every possible element and relationship in context of EL and to display all of them at once.
This may also lead to the question how the visualization is related to a visualization on a higher abstraction level and how they are connected and might be managed.
The latter may be investigated as an optional goal.

In addition to that a GUI-based editor should be developed as a prototype to make use of the proposed graphical specification language.



\section{Structure}
\label{structure}




\cleardoublepage
\chapter{Fundamentals}
\label{fundamentals}
This chapter provides information to fundamentals necessary for this thesis.
It will serve as a basis for design decisions in the following chapter~\ref{gsl_design} and chapter~\ref{editor_design}.

Section \ref{security_models} introduces two fundamental families of security models: IBAC and RBAC.
It also describes a graphical notation for depicting RBAC models by \cite{Sandhu96}.
This notation will serve as first basis for graphical modeling in this domain.
Section \ref{AOSE} focuses on the Aspect-oriented Security Engineering (AOSE) proposed by \citet*{Amthor18}.
It covers the Entity Labeling Aspect in particular, one aspect of AOSE, which is going to be essential regarding the task to design a graphical specification language for it.
Also the notation used by \citet*{Amthor18} to graphically model the process of Entity-Labeling, which was inspired by the graphical RBAC notation by \cite{Sandhu96}, will be described.
This will be the starting point in designing the graphical specification language in chapter \ref{gsl_design}.

In section~\ref{graphical_notations} the well-established graphical notations \textit{Unified Modeling Language} and \textit{Entity-Relationship} are described.
Based on human optical perception and gestalt laws section~\ref{perception} provides information on how we perceive and evaluate optical stimuli regarding properties like shape and closeness.
In the last section~\ref{gui_design} information on how to design a software graphical user interface are given with respect to common best practices like interaction design patterns and usability.

\section{Security models}
\label{security_models}
A \textit{security policy} is a set of rules to fulfill security related requirements of an IT system.
In order to be able to work with such a security policy and to analyze it, it has to be formalized as an instance of a \textit{security model}.
Being the central artifact in the process of model-based security engineering we want to describe a very basic security model -- the \textit{Identity-based Access Control} (IBAC) model -- and a well-established and widely used extension of it -- the \textit{Role-based Access Control} (RBAC) model.
In the course of this work, we need security policies and models to explain and visualize model-based security engineering with regard to Entity Labeling.

%\subsection{HRU}
%\label{HRU}
%The HRU security model \citep*{Harrison75a} is a fundamental, dynamic access control model.
%It manages permissions of subjects on objects with the help of an state automaton and access control matrices.
%While subjects are active (e.g. users), objects are passive (e.g. files).

%\begin{xdefinition}[HRU] 
%A HRU model is a deterministic automaton
%$(Q, \Sigma , \delta , q_{0})$ with 
%$Q = 2^S \times 2^O \times M$ as state space, 
%$M = \lbrace m|m:S \times O \rightarrow 2^R \rbrace$ as set of access control matrices, 
%$\Sigma$ as input alphabet, 
%$\delta : Q \times \Sigma \rightarrow Q$ as state transition function and 
%$q_0 \in Q$ as initial state.
%\end{xdefinition}



\subsection{Identity-based Access Control}
\label{IBAC}
The most fundamental class of security models is probably the family of Identity-based Access Control (IBAC) models.
The model is based on a system with active (subjects) and passive entities (objects).
In IBAC requests are decided according to the unique identification of the requester and the object \citep{Lampson74}.
A set of rules (\textit{policy}) determines whether a request is permitted or forbidden.
These rules can be formulated as access control matrix (ACM) or access control function (ACF).
An ACF is defined as following \citep{Amthor18}:

\begin{definition}[Access control function]
An access control function (ACF) is a function ${acf}: S \times O \times OP \rightarrow \mathbb{B}$, where
\vspace{-2mm}
\begin{itemize}
\item $S$ is a set of \textit{subject identifiers}
\item $O$ is a set of \textit{object identifiers}
\item $OP$ is a set of \textit{operation identifiers}
\end{itemize} 
\vspace{-2mm}
For any $s \in S, o \in O, op \in OP$, we say $s$ is allowed to execute $op$ on $o$ iff $acf(s,o,op)$.
\end{definition}



\subsection{Role-based Access Control}
\label{RBAC}
With an increasing number of subjects and objects the access control functions/matrices of IBAC models get very large and hard to manage effectively.
Role-based Access Control (RBAC) models counter this scalability problem by adding one stage of indirection.
For this RBAC models extend IBAC with the concept of roles \citep{Sandhu96}.
This design decision is based on the finding of \cite{Sandhu96} that in large systems many subjects share the same access privileges.
On the one hand every user is mapped to a set of roles.
On the other hand every role is mapped to a set of permissions.
This concept reduces redundancy in systems with large or fast growing sets of subjects and objects and also models real scenarios closer to reality (e.g. job function in an organization).

\begin{xdefinition}[RBAC] 
A RBAC$_0$ model is a tuple $(U, R, P, S, UA, PA, user, roles)$ with

\vspace{-2mm}
\begin{itemize}
\setlength\itemsep{0em}
\item $U$ as set of \textit{users}
\item $R$ as set of \textit{roles}
\item $P = 2^{O \times OP}$ as set of \textit{permissions}
\vspace{-2mm}
\begin{itemize}
\item $O$ is the set of \textit{objects}
\item $OP$ the set of \textit{operations})
\end{itemize}
\vspace{-2mm}
\item $S$ as set of \textit{sessions}
\item $UA \subseteq U \times R$ as a many-to-many \textit{user-to-role assignment relation}
\item $PA \subseteq P \times R$ as a many-to-many \textit{permission-to-role assignment relation}
\item $user: S \rightarrow U$ as function, that maps every session to a single user
\item $roles: S \rightarrow 2^R$ as function, that maps every session to set of roles
\end{itemize}
\label{definition:RBAC}
\end{xdefinition}

\noindent
RBAC is called a family of security models, because there is a base model (RBAC$_0$) and three models that extend this base model with advanced concepts.
RBAC$_1$ extends RBAC$_0$ with a role hierarchy, because in reality it turned out that roles are often combinations of other already existing roles.
This reduces redundancy and improves RBAC's scaling behavior even further.
The role hierarchy is defined as partial order $RH \subseteq R \times R$.% on $R$. %(also written as $\geq$).

RBAC$_2$ extends RBAC$_0$ with a set of constraints $C$ to restrict values of the model components $UA, PA, user, role$ or $RH$ (e.g. ``\textit{forbid the activation of two certain roles at the same time}'').
Constraints are highly individual and specific to a certain application.
However, \cite{Sandhu96} mentions three main concepts for constraints, that seem to be used frequently and are therefore reasonable to implement: \textit{Mutually exclusive roles}, \textit{cardinality} and \textit{prerequisite roles}.

RBAC$_3$ combines the concepts of RBAC$_1$ and RBAC$_2$.

%In contrast to automaton-based security models (e.g.~HRU), RBAC is static.
%Due to not being dynamic a RBAC model can always just reflect a snapshot in time.
%A dynamic variant of RBAC was proposed by \cite{Schlegel13} and is called DRBAC.
%It combines the RBAC$_3$ model with a deterministic state automaton of the HRU model.

%\begin{xdefinition}[DRBAC] 
%A DRBAC model is a tuple 
%$(Q, \Sigma , \delta , q_{0}, OP, R, RH, C)$ with
%$Q = 2^U \times 2^O \times 2^P \times 2^S \times 2^{\mathit{PA}} \times %2^{\mathit{UA}} \times \mathit{USER} \times \mathit{ROLES}$ as state space, where $U, O, P, S, PA, UA, RH, C$ is defined just as in the RBAC$_3$ model, 
%$\mathit{USER} = \lbrace user|user: S \rightarrow U \rbrace$ as set of mappings that maps sessions to users, 
%$\mathit{ROLES} = \lbrace roles|roles: S \rightarrow 2^R \rbrace$ as set of mappings that maps sessions to roles, 
%$\Sigma = OP \times X$ as input alphabet, 
%$\delta : Q \times \Sigma \rightarrow Q$ as state transition function, 
%$q_0 \in Q$ as initial state and 
%$OP, R, RH, C$ as static component.
%\end{xdefinition}



\subsubsection{RBAC notation by Sandhu at al.}
\label{RBAC_notation}
\cite{Sandhu96} use a graphical notation in their work to visualize the RBAC model family with all its elements and relationships (see figure \ref{fig:Sandhu_notation}).
Due to RBAC being a well-established security model and also regarding its relevance in literature -- especially for its contribution to the standardized NIST RBAC model \citep{RBACNIST} -- we want to take a closer look at its graphical notation.
Unfortunatly \cite{Sandhu96} gives no details on how or why the notation is build up the way it is in his work.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth-2cm]{../figures/chapter2/Sandhu_notation.png}
	\caption{Graphical notation to visualize $RBAC_3$ by \cite{Sandhu96} }
	\label{fig:Sandhu_notation}
\end{figure}

\noindent
Following graphical elements are used in this notation:

\begin{itemize}
\item A circle or ellipse represents a set ($U, R, P, S$).
\item A rounded rectangle represents a special set -- the set of \textit{Constraints}.
\item A normal-headed unidirectional arrow represents a one-to-one assignment ($user$).
\item A double-headed unidirectional arrow represents a one-to-many assignment ($roles$).
\item A double-headed bidirectional arrow represents a many-to-many assignment relation ($UA, PA, RH$).
\item A normal-headed unidirectional dotted arrow represents a constraint.
Six arrows of this type are pointing symbolically from the set of constraints in the direction of all model components constraints can be potentially defined on.
\end{itemize}
%TODO: Better a table?

\noindent
A set has its name and its identifier in its center.
An arrow -- except the constraint arrow -- has its identifier and optionally its name next to it.

Furthermore the set \textit{Sessions S} is not directly connected with arrows to other components.
It is drawn with large black dots inside, which represent single elements of this set.
These set elements are then connected to other components with certain arrows.
Three small black dots (in this case aligned horizontally) indicate that those three set elements are just symbolic and that there are potentially more or less (the number of sessions is not limited per definition).

This diagram is often used in a simplified form (for example in \citep{Amthor18}) that does not display single set elements of \textit{Sessions S}, but directly connects \textit{Sessions S}-- like the other sets -- with just one arrow (for the \textit{user} function) to \textit{Users} and one arrow (for the \textit{roles} function) to \textit{Roles}.
Also worth mentioning is that the \textit{Role Hierarchy RH} is drawn as a loop. 
It is pointing from \textit{Roles} ($R$) to \textit{Roles} with a double-headed bidirectional arrow.

Sandhu's notation depicts the overall structure of the RBAC model with its relationships between model components.
Different arrow types indicate different types of relationships.
Besides \textit{Sessions S} no set displays any set elements.
Also no set displays any kind of definition for its elements.
For example \textit{Permissions P} does not indicate that its elements are defined as $2^{O \times OP}$ (as in the RBAC definition, see definition \ref{definition:RBAC}).

%maybe my own gsl from bachelor thesis?


%\subsection{Security Model Core}
%\label{model_core}
%Over the years many different security models emerged for special purposes and requirements.
%They heavily vary and differ in their structure and design.
%Comparing them or even parts of them for analysis or evaluation purposes is not always possible per se.
%Methods to analyze a model concerning a given security property have to be adapted to every model they should run on.
%So \cite{Poelck14} proposed the Security Model Core to describe and formalize all possible security models in one meta model in a homogeneous way.

%\begin{xdefinition}[Security Model Core]
%\label{def:SecurityModelCore}
%The Security Model Core is a 5-tuple 
%$(Q, \Sigma , \delta , q_{0}, E)$ with 
%$Q$ as state space,
%$\Sigma$ as input alphabet, 
%$\delta: Q \times \Sigma \rightarrow Q$ as state transition function, 
%$q_0$ as initial state and 
%$E$ as static extension vector.
%\end{xdefinition}

%The definition of model components depends on the specialization of the corresponding model core and is done in six steps by identifying and defining those components.



\section{Aspect-oriented Security Engineering}
\label{AOSE}
In this section the Aspect-oriented Security Engineering proposed by \cite{Amthor18} is described with focus on its Entity Labeling aspect.
The content of this section will act as fundamental basis of information for designing a graphical specification language for the Entity-Labeling aspect later in chapter \ref{gsl_design}.

Aspect-oriented Security Engineering (AOSE) is a new approach proposed by \cite{Amthor18} to improve the process of model-based security engineering.
With an increasing number and complexity of security models the engineering process that goes along also became more complex and therefore prone to human errors.
\cite{Amthor18} claims to close semantic gaps between model engineering, model analysis and formal policy specification in the process of security engineering to reduce the potential impact of human errors.
These three steps and how they connect are depicted in figure \ref{fig:AOSE}.

\begin{figure}[htb]
	\centering
	\includegraphics[scale=0.4]{../figures/chapter2/AOSE.png}
	\caption{Steps of model-based security engineering \citep{Amthor18}}
	\label{fig:AOSE}
\end{figure}

\noindent
AOSE roughly adopts the idea of the aspect-oriented programming paradigm.
It tailors all steps to aspects, which are non-functional requirements of the engineering process, for example determining requirements of policy semantics or analyzing certain security goals.
There are two major classes \cite{Amthor18} proposes for aspects regarding AOSE: related to policy semantics and related to policy analysis.
One of several aspects proposed in his work is Entity Labeling.

According to \cite{Amthor18} an aspect-oriented security model is defined as:

\begin{xdefinition}[Aspect-oriented security model] 
A aspect oriented security model is defined as 
\begin{gather*}
\langle \mathcal{M},\mathcal{A},sem \rangle
\end{gather*}
with:

\vspace{-2mm}
\begin{itemize}
\setlength\itemsep{0em}
\item $\mathcal{M}$ as finite set of model component identifiers
\item $\mathcal{A}$ as set of semantic category identifiers (aspect)
\item $sem : \mathcal{A} \rightarrow 2^\mathcal{M}$ as semantical application of $\mathcal{A}$ to $\mathcal{M}$
\end{itemize}
\label{definition:AOSE}
\end{xdefinition}



\subsection{Entity Labeling}
\label{EL}
The Entity Labeling (EL) aspect is one possible aspect $\mathcal{A}$ in context of AOSE (see definition \ref{definition:AOSE}).
It is designed to support the process of formally specifying policy semantics typically found in operating systems and middleware systems.
According to \cite{Amthor18} it bridges the gap between informal policy and formal model by supporting its transformation (see highlighted part in figure \ref{fig:AOSE}).

For this model components of an informally specified policy have to be identified and formalized by classifying them into the six semantic categories $ES$, $LS$, $LA$, $AR$, $RR$, and $MC$:

\begin{description}
\item[1) Entity Set (ES)]\hfill \\
\textit{ES} is a set of entity identifiers.
Basic elements in context of access control decisions are defined as \textit{entities} and are resources and principals like subjects or objects.
%\vspace{-2mm}

%\begin{xdefinition}[ES] 
%ES model components are sets that list potential participants in access decisions.
%Elements of those sets are (1) atomic identifiers, (2) legal argument values for any authorization decision, (3) illegal argument values for evaluating \textit{AR} model components and (4) associated with labels via \textit{LA} model components.
%\label{definition:ES}
%\end{xdefinition}

\item[2) Label Set (LS)]\hfill \\
\textit{LS} is a set of legal label values.
Labels act as attributes in access control decisions and therefore as level of indirection.
Their content vary depending on a policy's application domain and can be finite enumerations (e.g.~RBAC), infinite enumerations (e.g.~ABAC) or any number system such as $\mathbb{N}$.
%\vspace{-2mm}

%\begin{xdefinition}[LS] 
%LS model components are sets that list identifiers used in entity labels.
%Elements of those sets are (1) legal attribute values in labels, (2) legal argument values for evaluating \textit{AR} model components, (3) illegal argument values for any authorization decision and (4) may be associated with labels via \textit{LA} model components.
%\label{definition:LS}
%\end{xdefinition}

\item[3) Label Assignment (LA)]\hfill \\
\textit{LA} is a set of associations between entities and labels.
%\vspace{-2mm}

%\begin{xdefinition}[LA] 
%LA model components are assignments that determine a system configuration in terms of how a policy's access rules (\textit{AR}) are applied to entities (\textit{ES}). They (1) are used to associate entity identifiers with label identifiers, (2) may be used to associate label identifiers with label identifiers and (3) indirectly determine any authorization decision.
%\label{definition:LA}
%\end{xdefinition}

\item[4) Access Rule (AR)]\hfill \\
\textit{AR} is a logical rule that defines, based on a set of entity labels, which operations may be legally performed on entities corresponding to these labels. Model components in \textit{AR} thus reflect a policy’s access control function.
%\vspace{-2mm}

%\begin{xdefinition}[AR] 
%\textit{AR} model components are logical rules which (1) are evaluated using label identifiers and (2) directly determine any authorization decision.
%\label{definition:AR}
%\end{xdefinition}

\item[5) Relabeling Rule (RR)]\hfill \\
\textit{RR} is a logical rule for legal label changes.
Label changes can emerge from either administrative accesses (e.g.~RBAC's \textit{UA}) or discretionary accesses (user owns files and grant roles/users access).
%\vspace{-2mm}

%\begin{xdefinition}[RR] 
%\textit{RR} model components are logical rules which (1) define relations between \textit{ES} or \textit{LS} model components and (2) restrict changes of \textit{LA} model components.
%\label{definition:RR}
%\end{xdefinition}

\item[6) Model Constraints (MC)]\hfill \\
\textit{MC} is a set of constraints over model components that must be satisfied at all time.
There are two types of constraints: policy-intrinsic (related to variables managed inside the AC system) and policy-extrinsic (related to external variables, e.g.~time).
%\vspace{-2mm}

%\begin{xdefinition}[MC] 
%MC model components are boolean expressions or external variables. 
%They represent conditions which (1) may relate to all model components (including external variables), (2) must be satisfied by the values of all model components (excluding external variables) and (3) must be satisfied after any change of the model components.
%\label{definition:MC}
%\end{xdefinition}
\end{description}

%\noindent
%According to these categories EL is defined as following:

%\begin{xdefinition}[Entity Labeling aspect] 
%The Entity Labeling aspect of a security policy is defined as:
%\begin{gather*}
%\mathcal{A}_{EL} = \lbrace ES,LS,LA,AR,RR,MC\rbrace
%\end{gather*}
%where $ES$, $LS$, $LA$, $AR$, $RR$, and $MC$ denote categories of model components defined as in definitions \ref{definition:ES} to
%\label{definition:EL} \ref{definition:MC}.
%\end{xdefinition}

\noindent
The resulting model after EL can be depicted in three different forms: Textual, table and graphical.
The textual form created from an example policy looks like this:

\begin{align*}
\langle &\mathcal{M}_{example}, \mathcal{A}_{EL}, sem \rangle
\end{align*}
\begin{align*}
\mathcal{M}_{example} &= \lbrace U, D, R, GR, AR, P, ua, da, pa \rbrace
\end{align*}
\begin{align*}
sem(ES) &= \lbrace U, D \rbrace\\
sem(LS) &= \lbrace R, P \rbrace\\
sem(LA) &= \lbrace ua, da \rbrace\\
sem(AR) &= \lbrace pa, P \rbrace\\
sem(RR) &= \lbrace GR, AR, ua \rbrace\\
sem(MC) &= \lbrace \emptyset \rbrace
\end{align*}

\noindent
Figure \ref{fig:EL_table} shows the same result as table.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth-3cm]{../figures/chapter2/EL_table.png}
	\caption{Result of EL-based model engineering \cite[p.77, table 4.1]{Amthor18}}
	\label{fig:EL_table}
\end{figure}

\noindent
The first column contains the EL categories.
The second column shows all given informal model components.
They are classified into the EL categories by assigning them into the corresponding row.
In the third column those model components are formalized as sets, mappings, relations, etc.
The last column refers to the corresponding informal rule of the example policy the model components originate from.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth-6cm]{../figures/chapter2/EL_diagram.png}
	\caption{Visual summary of figure \ref{fig:EL_table} \cite[p.76, figure 4.3]{Amthor18}}
	\label{fig:EL_diagram}
\end{figure}

\cite{Amthor18} also used a graphical depiction (see figure \ref{fig:EL_diagram}) that is loosely based on the notation by \cite{Sandhu96} (see section \ref{RBAC_notation}).
In this diagram members of EL categories are visually classified by being horizontally aligned to a category space.
The category spaces are indicated with dotted lines at the bottom of the diagram.

As in the RBAC notation (see section \ref{RBAC_notation}) circles are used to depict sets.
Subsets are depicted as smaller circles inside their supersets.
Simple one-headed arrows depict mappings.
Arrows are drawn between members of \textit{ES} or \textit{LS}.
They just indicate a direction and not any properties or typing of the given relationships.
In figure \ref{fig:EL_diagram_m} there is also a double-headed arrow for depicting a relation (again analogue to the RBAC notation).

In contrast to its graphical origin -- the RBAC notation by \cite{Sandhu96} -- this notation is tailored specifically to the domain of EL.
It roughly takes the graphical elements of the RBAC notation, simplifies them to some degree (less arrow head types, ignoring set elements) and extends the system with dotted sections to indicate its EL categories.
However this notation is imprecise and ambiguous to some extent.
This especially becomes evident when comparing the notation to ELs table form.

The initial motivation for proposing the EL aspect was to support security engineering, e.g. by improving the communication between different people involved in the process.
This can be achieved by using a graphical notation, but will not be any useful support, when the notation is not defined unambiguously and consistently.
In chapter \ref{gsl_design} we will start off with this notation and try to identify its problems to create a more powerful notation system.

\subsection{Hierarchical Entity Labeling}
\label{HEL}
To further improve scalability another level of indirection can be iteratively added to an EL model that already has one level of indirection (e.g. adding a role hierarchy like RBAC has).
For this additional \textit{LS} and \textit{LA} components are added to the EL categories.
In this context $m$ indicates the degree of indirection.
For $m>1$ the EL aspect is defined by \cite{Amthor18} as:

\begin{align*}
\mathcal{A}_{EL(m)} = \lbrace ES,LS_1, \dots,LS_m, LA_1, \dots, LA_m,AR,RR,MC\rbrace
\end{align*}

\noindent
Adding a role hierarchy to our example policy from above will alter $sem(LA)$ to $sem(LA_1)$ and $sem(LS)$ to $sem(LS_1)$ and will add following two assignments:

\begin{align*}
sem(LS_2) &= \lbrace R \rbrace\\
sem(LA_2) &= \lbrace RH \rbrace\\
\end{align*}

\noindent
This leads to a diagram with an additional component $RH$ and multiple sections for $LS_i$ and $LA_i$ as depicted in figure \ref{fig:EL_diagram_m}.
The category spaces at the bottom are now not the only indications for categories in this diagram.
$LA_2$ and $LS_2$ are depicted as dotted-lined rectangles within the diagram itself and frame its components $RH$ and $R$.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth-6cm]{../figures/chapter2/EL_diagram_m.png}
	\caption{Visual summary with $m=2$ (not showing \textit{AR} and \textit{GR}) from \cite[p.79, figure 4.4]{Amthor18}}
	\label{fig:EL_diagram_m}
\end{figure}



\section{Graphical notation models}
\label{graphical_notations}
In this section two well-established graphical notation models are presented: UML and ER.
Due to being standard and de facto standard, they have a high relevance in the domain of graphical modeling. 
UML and ER come with reasonable concepts to illustrate structural information and semantic properties (for types of information visualization in science see section \ref{perception}).

\subsection{Unified Modeling Language}
\label{UML}
The \textit{Unified Modeling Language} (UML) is a graphical modeling language to specify, visualize, design and document software \citep{UML_OMG}.
UML became a widely used tool in software development and was standardized by The Object Management Group in 1997 and also was approved as official ISO standard in 2005 \citep{UML_ISO}.

%UML defines terms and relationships between those terms, as well as a graphical notation for those.
The current version of UML (2.5) contains 14 different types of diagrams.
Every diagram illustrates information according to one specific aspect.
UML diagrams are classified into static and dynamic types, but they can have fuzzy borders and mixed forms as well.
Static diagram types describe structural properties, dynamic diagram types behavioral properties.



\subsubsection{Components}
Components an UML diagram is build up with are classified into \textit{elements} and \textit{relationships}:

\begin{description}
\item[1) Elements]\hfill \\
Elements are the main artifacts in an UML diagram.
Graphically elements are based on closed shapes like boxes or ellipses.
They usually have a name or identifier in form of text in the center of their shape. Horizontal lines can be used to separate an element into two or more sections (see \textit{class} element). \\
Examples for elements are classes, packages, ports, etc.~(see figure \ref{fig:UML_elements}).
Elements can be closely tied to specific diagram types (e.g.~components to component diagrams).

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth]{../figures/chapter2/UML_elements.png}
	\caption{Selection of UML elements}
	\label{fig:UML_elements}
\end{figure}

%\noindent 
%Some elements can have multiple forms.
%For example the class element has a simple symbolic form as well as an extended form with detailed information (see figure \ref{fig:Class}).
%With this option whole diagrams can be dynamically adjusted to a desired level of detail.
%
%\begingroup
%\leftskip10em
%\begin{figure}[htb]
%	\centering
%	\includegraphics[width=\linewidth]{../figures/chapter2/UML_Klassen2.png}
%	\caption{Class diagrams with different level of detail}
%	\label{fig:Class}
%\end{figure}
%\par
%\endgroup

\item[2) Relationships]\hfill \\
Relationships can connect two or more elements.
Graphically relationships are lines.
Optionally they can have a shape at one end to indicate a direction.
They can vary in form by having differently drawn lines (solid, dotted) or shaped arrow heads.
They can have several angles (preferable $90^{\circ}$ or $45^{\circ}$) to run on a clearly laid out path.
Lines do not collide if possible. \\
Examples: Dependency, generalization, include (see figure \ref{fig:UML_relationships})

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth]{../figures/chapter2/UML_relationships.png}
	\caption{Selection of UML relationships}
	\label{fig:UML_relationships}
\end{figure}
\end{description}



\subsubsection{Additional annotations}
\label{UML_additional_annotations}
UML has symbols and textual identifiers to visualize certain properties.
With \textit{multiplicities} an element can be constrained regarding its number in context of an relationship.
The notation is placed at the connection point of class and relationship component.
In almost all cases it is depicted as integer number (0 or 1) or * to indicate a boundless interval.

Furthermore it is worth mentioning that UML does not use any color for its diagrams.
This makes it compatible, easy and fast for hand-drawing.
Coloring remains a not officially specified option to highlight certain parts of a diagram, e.g. to set a focus without being in conflict with any already colorized sections of the model.


\subsection{Entity-Relationship model}
\label{ER}
The entity-relationship model (ER) is a model to describe classified objects (entities) and how they are interrelated.
It was developed to illustrate information in databases on a conceptual level and became a popular tool for requirement analysis in this domain.
In contrast to UML (see section \ref{UML}) ER only has one type of diagram: The Entity-Relationship diagram (ERD).
Also unlike UML ER is not an officially specified standard.
ER has different notation variants (Chen, Bachman, etc.), which will be depicted in section \ref{ERD_notations}.
Figure \ref{fig:ERD_minimal_example} shows an example of an ERD.


\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth]{../figures/chapter2/ERD_minimal_example.png}
	\caption{ERD example}
	\label{fig:ERD_minimal_example}
\end{figure}

\subsubsection{Components}
ERDs are build up with the following components \citep{Kleuker11}:

\begin{description}
\item[1) Entity type]\hfill \\
The most important artifact of ER is probably the entity.
It represents an individual and unambiguously identifiable object.
An entity is characterized by its properties.
An \textit{entity type} is a template for entities that summarizes all their attributes.
Entities can be interpreted as instances of an entity type with concrete values.
Graphically an entity type is a simple rectangle with its name in its center.

\begin{figure}[htb]
	\centering
	\includegraphics[scale=0.4]{../figures/chapter2/ERD_entity.png}
	\caption{Entity object of an ERD}
	\label{fig:ERD_entity}
\end{figure}

\item[2) Relationships]\hfill \\
Relationships can connect two or more entities and describe how they are interrelated.
In contrast to UML (see \ref{UML}) relationship is not represented with a simple lines, but with a rhombus with the relationship name in its center.
This rhombus is then connected to two or more entities with simple lines.
These lines may have symbols at their end to indicate properties of the connected entities in context of the relationship.

\begin{figure}[htb]
	\centering
	\includegraphics[scale=0.4]{../figures/chapter2/ERD_relationship.png}
	\caption{Relationship object of an ERD}
	\label{fig:ERD_relationship}
\end{figure}

\item[3) Attributes]\hfill \\
Attributes are properties of entites or relationships.
Graphically an attribute is a single ellipse with its name in its center.
It is connected to an entity or to a relationship with the help of a simple line.

\begin{figure}[htb]
	\centering
	\includegraphics[scale=0.4]{../figures/chapter2/ERD_attribute.png}
	\caption{Attribute object of an ERD}
	\label{fig:ERD_}
\end{figure}
\end{description}

\subsubsection{Additional annotations}
\label{ER_additional_annotations}
To specify the amount of entities in context of a relationship the following indicators for \textit{cardinalities} are used:

\begin{itemize}
\setlength\itemsep{0em}
\item \textbf{1} to indicate a relationship to exactly one entity.
\item \textbf{c} to indicate a relationship to no or one entities.
\item \textbf{n} to indicate a relationship to one or multiple entities.
\item \textbf{nc} to indicate a relationship to no, one or multiple entities.
\end{itemize}

\noindent
%Cardinalities can be upper case (N) or lower case (n) with no semantic difference.
A relationship can be read in two directions.
For example the \textit{orders}-relationship in figure \ref{fig:ERD_minimal_example}:

\begin{itemize}
\setlength\itemsep{0em}
\item An order is connected to exactly one client (left-to-right).
\item A client is connceted to no, one or multiple orders (right-to-left).
\end{itemize}

\noindent
An entity type needs to have a \textit{primary key} defined in order to have its elements unambiguously identifiable.
The primary key is an attribute or a combination of attributes of the entity type and has to be unique among all other attribute values.
A primary key attribute is graphically indicated with an underlined name (see \textit{ClientID} in figure \ref{fig:ERD_minimal_example}).

%Besides this basic system, ERDs can indicate some additional information.
%For example besides those elements described above, there are variants of them with a double frame line to indicate a \textit{weak} property (no primary key, dependent to parent elements) or a dashed frame line to indicate a \textit{multivalued} property.
%In context of this work those will not be relevant.



\subsubsection{ERD Notation Variants}
\label{ERD_notations}
As already mentioned ER is not standardized and has different notation variants.
These variants only differ in the depiction of their relationships (see figure \ref{fig:ERD_notations}).

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth+0.3cm]{../figures/chapter2/ERD_notations.png}
	\caption{ERD notation variants}
	\label{fig:ERD_notations}
\end{figure}

\noindent
% ERD as UML
Notable is also that an ER model can be visualized with the help of UML.
When entity types are treated as classes, entities as objects, relationships as associations, attributes as instance variables and cardinalities as multiplicities an UML \textit{class diagram} can be used to build up a diagram that is similar to an ERD.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth+0.2cm]{../figures/chapter2/ERD_as_UML.png}
	\caption{ERD modeled as UML class diagram}
	\label{fig:ERD_as_UML}
\end{figure}

%\noindent
%As seen in figure \ref{fig:ERD_as_UML} the diagram visually differs from the diagram in figure \ref{fig:ERD_minimal_example}, but can depict the information even more compact.
%However, there is no common way for indicating an entity type's primary key in UML (the UML extension concept of \textit{stereotypes} can be used for this).



\section{Perception}
\label{perception}
This section is about the human visual perception.
Its content will act as fundamental basis for designing a graphical specification language in chapter \ref{gsl_design} as well as for designing an editor's graphical user interface in chapter \ref{editor_design}.

In science there are two types of visualizing information:
One is to present absolute or relative primitive values (tables, bar graphs, pie charts) and one to depict structural information and semantic properties (specialized graphical systems like the class diagram of UML or the Chen notation of ERD).
Designing a new system of the latter should consider design guidelines and rules of best practice to visually support working with it.
One of these are gestalt laws.

\subsection{Gestalt Laws}
\label{gestalt_laws}
Gestalt laws (from German \textit{Gestalt}: shape, form) are derived from findings in the human perception of visual content.
They describe phenomena of how we perceive and evaluate objects and groups of objects in context to each other intuitively.

These laws apply in particular when we look at graphical user interfaces (\textit{GUI}), graphs or diagrams.
They can describe how and why we look at certain aspects first or find some aspect more easy or hard to understand than another.
Considering gestalt laws while designing any graphical content can improve its perception quality and therefore also the handling for its readers or users.

Given that there is a large number of various gestalt laws, the following list (based on \citep{Goeckel01a}, \citep{Heinecke04a} and \citep{Sternberg}) describes some of them that are relevant for the task of designing a graphical specification language in chapter \ref{gsl_design}:

\begin{description}
\item[1) Law of Prägnanz]\hfill \\
The Law of Prägnanz (German for \textit{pithiness}) is the fundamental principle of gestalt laws.
It says that humans tend to order inputs of their senses in the best possible way (simple, regular, symmetrical).
This results in phenomena like completing incomplete forms or favoring closed objects or treating groups of objects as units.

\item[2) Law of Proximity]\hfill \\
Objects that are closer together are not associated individually but as groups.
Smart utilizing this law offers opportunities to design visually separated sections without the help of any lines or boxes.

\item[3) Law of Similarity]\hfill \\
Homogeneously depicted objects are associated as belonging together, although they may not be in close range to each other.
This effect can be induced by \textit{Gestalt factors} like shape, color, brightness, size, orientation or rotation.
%This law allows classifying or logically grouping multiple spatially distributed objects.

\item[4) Law of Good Gestalt]\hfill \\
While looking at complex structures of objects, details are ignored and objects will always be perceived in the most simple, regular and symmetric pattern they will form.

\item[5) Law of Good Continuation]\hfill \\
Two overlapping objects are often perceived as uninterrupted.
This law allows straight lines to intersect without any confusion.
\end{description}



\subsection{Human Optical Perception}
\label{human_optical_perception}
\textit{Semiosis} is the science of signs.
It deals with analyzing signs and how they transport information \citep{Zeckzer14a}.
Semiosis differentiates between \textit{sensory symbols} and \textit{abstract symbols}.
Sensory symbols are based on biologically preset perception processes and can be recognized without any additional information (e.g.~the shape of a human body).
Abstract symbols can be chosen freely and have to be learned, because they have no relation to its reference (e.g.~the mathematical sign for infinity $\infty$).
Software applications use sensory symbols to make its functions independent from text (and therefore a specific language).
Besides sensory symbols also abstract symbols have established for common actions (e.g.~\textbf{+} to add, \textbf{-} to remove, \textbf{ \underline{ }} to minimize, \textbf{$\times$} to close, etc.)

\cite{Zeckzer14a} describes that humans are able to hold 3 to 7 elements in their visual buffer inside their short term memory.
This buffer size limits our processing capacity and visual awareness.
Handling more than this number of symbols will result in understanding a graphical system more ineffectively.

According to \cite{Ware04a} optical stimuli are perceived and processed in three consecutive steps with differently set priorities depending on their content:

\begin{description}
\item[1) Parallel processing to extract low-level characteristics]\hfill \\
In this first step inputs are processed in parallel by millions of neurons in high speed.
The inputs are then evaluated regarding their orientation, movement and overall color impression.

\item[2) Perception of pattern and structures]\hfill \\
In this second step the picture gets separated into regions.
Simple structures like contours, colors and textures get recognized.
Object recognition begins.

\item[3) Sequential target-oriented processing]\hfill \\
In this last step single recognized objects get selected and stored in the short term memory.
There they are ready for further processing, e.g.~applying of knowledge or emotions.
\end{description}



\section{GUI Design}
\label{gui_design}
The \textit{graphical user interface} (GUI) is a well-established interface type that allows interactions between human and machine on a graphical level.
It presents visual content to its users and offers functions to operate with the help of symbols and control elements.
GUIs were developed, because text-based \textit{command line interfaces} (CLI) need a higher degree of memorization and familiarity for operation and navigation and therefore new users in particular find operating a CLI more difficult than a GUI \citep{CLI}.
Unfortunately GUI design often lacks ease of use, due to its design being tied too strictly to the work flow of experts \citep{Reckling14}.

There are some best practices to stick to when it comes to design a \textit{good} GUI.
One of them is to reuse already established methods and approaches like \textit{user interface pattern}.
Another one is to evaluate whether a design concept follows \textit{usability} rules.



\subsection{Usability}
\label{usability}
\cite{Shackel91a} defines usability as following:

\begin{xdefinition}[Usability] 
Usability is the capability to be used by humans easily and effectively, while
\begin{itemize}
\item \textit{easily} means ``to a specified level of subjective assessment'' and
\item \textit{effectively} means ``to a specified level of (human) performance''
\end{itemize}
\label{definition:usability}
\end{xdefinition}

\noindent
Usability can be classified into \textit{interaction design} and \textit{interface design}.
The former describes \textit{how} a system reactions to user interactions, the latter \textit{with what} a system visualizes interaction options \citep{Reckling14}.

\cite{Tidwell11} describes several principles essential for achieving a high usability.
These principles can be applied in form of non-functional requirements in the process of designing a new GUI.
The following list describes the first 6 of those principles:

\begin{description}
\item[1) Safe Exploration]\hfill \\
A user should always be able to safely explore the interface.
This includes undoing every operation he performs in particular.
%For this a software has to be designed as \textit{non-destructive} as possible.

\item[2) Instant Gratification]\hfill \\
A user should always instantly get feedback about operations he just performed.
This can be the direct result of his operation (e.g.~opening a window) or a visual hint, that an operation was executed as desired (e.g.~coloring an activated button).

\item[3) Satisfiscing]\hfill \\
\textit{Satisfiscing} (\textit{satisfying} and \textit{sufficing}) is the phenomenon that a user tends to scan all options just roughly and to use trial-and-error before finding the perfectly matching tool for a certain task.
He tends to be fine with solutions that are \textit{good enough} and not the best possible.
This means that the user should be supported to find the right tools when he needs them.
%For this symbols and texts have to be short, simple and easy to understand.
Elements and symbols already known should be reused when possible.
Also to ensure a correct order of operations or work flow (if necessary at all, see point 6 of this list) the user should be guided appropriately (e.g.~\textit{drag here}).

\item[4) Changes in Midstream]\hfill \\
A user should always be able to interfere with running operations to always have the control (e.g. a time consuming operation indicated with a progress bar together with a cancel button underneath).

%\item[5) Deferred Choices]\hfill \\
%A user should always be able to defer choices that are not mandatory and answer just the minimal set of questions that are necessary to progress at a certain point.
%Of course, besides this, the system has to offer a way for the user to come back to answer the skipped questions later.

\item[5) Incremental Construction]\hfill \\
Builder-style software like editors need to support \textit{incremental construction}.
This means that the user is free to choose on which particular part he wants to works.
A user should always be free to stop working on one part and instantly jump to another part to continue working there.
When this \textit{incremental construction} is achieved to a high degree, this can induce a state of flow in the user, which leads to an increased working performance and satisfaction.
\end{description}


\subsection{Interaction Design Patterns}
\label{design_patterns}
A GUI has to be designed a way it can be operated mostly intuitively.
This means that a user should find his way without knowing a new application.
This can be achieved by reusing graphical control elements and functions that are already well-established and known from working with other software's GUI.
These elements can be recognized by their similar visual appearance and will always work in a similar known way.
These elements are called \textit{interaction design patterns}.

An interaction design pattern is defined by \cite{Folmer} as a general repeatable solution to a commonly-occurring usability problem in \textit{interface} or \textit{interaction design}.
Interaction design pattern can be graphical elements like buttons, menus or scroll bars as well as control functions like drag and drop, swipe gestures or context-menu by clicking the mouse button.

Whenever these patterns fit, they should be applied.
Reinventing interaction design is not only very time consuming, but actually even counterproductive concerning usability due to users will get discouraged by being confronted with new unknown mechanisms (see section \ref{usability} \textit{satisfiscing}).



\cleardoublepage
\chapter{Design: Graphical Specification Language}
\label{gsl_design}
In this chapter we develop a notation to graphically model the Entity Labeling aspect (see section \ref{EL}) of Aspect-oriented Security Engineering.
In the first section \ref{gsl_concept} the general idea of how to achieve this and the overall concept are explained.
For this the notation used by \cite{Amthor18} is investigated regarding its completeness, consistency and general weaknesses.
In section \ref{gsl_elements} the graphical elements the system uses are explained, followed by section \ref{gsl_structure}, which depicts the overall structure of the system.
%Section \ref{higher_abstraction_level} will be about the visualization on a higher abstraction level (when $m>1$).



\section{Concept}
\label{gsl_concept}
%approach, basic ideas, adoptions from literature

Due to being highly tailored to one specific domain, established graphical notations for structural or semantic properties like UML or ER (see section \ref{graphical_notations}) are impractical for direct reuse in other domains.
A new concept like EL generally requires a newly designed graphical notation.
In reality needed elements, concepts and ideas are not always created from scratch, but are getting (partly) adopted from related systems and adapted accordingly as long as they fit syntactically and semantically.
With or without adoption: The system should be designed in a way its components are unambiguous to components of systems from similar or related domains to avoid misunderstanding or barriers in learning.
With this said we want to start off with the graphical notation \cite{Amthor18} uses to visualize the EL aspect and try to analyze and expose its problems in section \ref{analyzing_notation} and to propose solutions in section \ref{improving_notation}.



\subsection{Analyzing the EL notation used by Amthor}
\label{analyzing_notation}
The two major problems of the graphical EL notation used by \cite{Amthor18}, which makes it inconsistent and ambiguous, are the depicted relationships between elements and the method of classifying elements.

\vspace{4mm}
\noindent
\textbf{Problem 1: Ambiguously depicted relationships}
\vspace{1mm}

\noindent
When comparing the visual summary (figure \ref{fig:EL_diagram}) with the table form (figure \ref{fig:EL_table}) we find several inconsistencies.

One is that all mappings in the visual summary ignore the presence of power sets or similar expressions that can extend sets.
For example $ua: U \rightarrow 2^R$ is drawn as a simple arrow from $U$ to $R$.
The inconsistency (loss of information) becomes clear when converting the graphical statement back to a mathematical one:
\begin{align}
(U \rightarrow 2^R) \not\equiv (U \rightarrow R)
\end{align}

\noindent
Also mappings can have multiple input arguments.
Unfortunately \cite{Amthor18} does not depict any mapping example with multiple arguments, but we can easily imagine a simple mapping with two arguments: e.g.~a mapping that takes a subject's and an object's identification to decide whether an user action is allowed on an object or not (IBAC, see section \ref{IBAC}):
\begin{align}
S \times O \rightarrow R 
\end{align}

\noindent
The ad-hoc idea is to draw a line from $S$ and $O$, merge in one point and ending with an arrow head in $R$ (figure \ref{fig:inconsistent_two_arguments}) is not sufficient in terms of consistency, because the type of operation is not specified.
The operation, that determines how a mapping's arguments interrelate, can vary (here: $\times$, but may be $\cup, \cap, \setminus, \Delta$, \dots just as well).

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth-10cm]{../figures/chapter3/inconsistent_two_arguments.png}
	\caption{Inconsistent depiction of a mapping with two arguments}
	\label{fig:inconsistent_two_arguments}
\end{figure}

\noindent
Besides that, when handling two or more arguments the order of operations, which may be mathematically indicated with brackets, is relevant (see inequations below) and thus has to be considered and depicted as well:
\begin{gather}
\lbrace A \setminus B \rbrace \not\equiv \lbrace B \setminus A \rbrace \\
(\lbrace A \cap B \rbrace \cup C \rightarrow D) \not\equiv
(A \cap \lbrace B \cup C \rbrace \rightarrow D)
\end{gather}

\vspace{4mm}
\noindent
\textbf{Problem 2: Ambiguously depicted categorization}
\vspace{1mm}

\noindent
The EL categories are depicted by \cite{Amthor18} with dotted spaces at the bottom of a figure.
These allow a form of categorizing by horizontally aligning elements into sections.
Additionally elements can be categorized by surrounding them with a dotted box (e.g.~\textit{R} in $LS_2$ in figure \ref{fig:ambiguous_categorization}).
The horizontal alignment seems similar to a table categorization with columns, but unlike a table the graphical depiction uses arrows that connect elements to indicate a relationship between them.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\linewidth-8cm]{../figures/chapter3/ambiguous_categorization.png}
	\caption{Ambiguous categorization of a relation}
	\label{fig:ambiguous_categorization}
\end{figure}

When connecting two elements, which are positioned in different sections, arrows inevitably run through all sections lying between those sections.
But arrows do not always connect elements across two sections:
It is possible that they connect elements that are further away from each other or elements that belong to the same section.
For example in figure \ref{fig:ambiguous_categorization} \textit{RH} is placed above $R$, because it is no member of one of the horizontally adjacent categories of $LS_1$ ($LA_1$ and $AR$); nevertheless it is incorrectly associated with $LS_1$ due to its horizontal alignment.

So arrows will automatically be associated with
\begin{enumerate}[label=\alph*)]
\item (all) categories lying between elements they connect, when those elements are members of different categories or 
\item the category of a single element, when the relationship is a loop
\end{enumerate}
which is both unpreventable and undesired in many cases.

But not just arrows, also \textit{sets} have a similar issue, because they can be member of multiple categories at once.
In figure \ref{fig:ambiguous_categorization} we can construct such situation by adding a new element $E$, which is member of $LS_2$ and of a new category $C$, that is not horizontally adjacent to $LS_1$.
Therefore we have to either extend the dotted rectangle for $LS_2$ up to category $C$ (which then inevitable overlaps with other undesired horizontal categories and therefore gets associated with them) or we have to depict $E$ two times at once (in $LS_2$ and $C$), which makes the figure inconsistent again, but also redundant and thus confusing.



\subsection{Improving the EL notation used by Amthor}
\label{improving_notation}
\vspace{2mm}
\noindent
\textbf{Solution to problem 1: Relationship annotations and type indicators}
\vspace{1mm}

\noindent
To counter the first major problem of the graphical EL notation used by \cite{Amthor18} we need a better way to depict relationships.
This is done with two extensions: Annotations and type indicators.

For indicating extended expressions for sets in context of a relationship like power sets we introduce \textit{relationship annotations}.
These are simliar to UML's multiplicities (see section \ref{UML_additional_annotations}) or ERD's capacities (see section \ref{ER_additional_annotations}) and are positioned at the connection points of sets and relationships (see figure \ref{fig:relationship_annotation}).
Unlike its semantics in UML or ERD, these relationship annotations do not indicate the (relative) amount of elements participating in a relationship, but describes a specific form of an element in context of a relationship it is part of.
Just like UML/ERD the mathematical expression (e.g.~$2^R$) is depicted directly as textual expression without any additional graphical elements or symbols.
This makes it universal to depict any mathematical expression.

\begin{figure}[htb]
	\centering
	\includegraphics[scale=0.4]{../figures/chapter3/relationship_annotation.png}
	\caption{Relationship annotations for improved set expressions}
	\label{fig:relationship_annotation}
\end{figure}

At this level of detail specifying special graphical elements (e.g.~differently shaped arrow heads) for every possible expression is not reasonable due to the high amount of different elements needed.
This may be even counter-intuitive, because humans are able to hold up to 7 different elements in their visual buffer at once; beyond that learning/working becomes harder due to constantly swapping information between cerebral areas (see section \ref{human_optical_perception} about human optical perception).

The second extension is the \textit{type indicator}, which allows specifying the type of operation between two elements of a relationship.
In the notation \cite{Amthor18} uses, relationships do not specify any internal operation type between elements, just the relationship type with the depiction of different arrows (mapping, relation, constraint).
Therefore any relationship is depicted incompletely due to not knowing in which way its sets are interrelated ($\times, \cup, \cap, \setminus, \Delta$, \dots).
Just like before it seems not reasonable to introduce new graphical elements for the purpose of indicating the type of operation at this level of detail and with that amount of different possible types.
Again we use the textual mathematical expression/symbol.
It is positioned in the middle of its corresponding relationship arrow.
To avoid proximity and overlapping conflicts in case of short arrows or intersecting arrows the textual indicator is placed inside a graphical shape: a rhombus (based on ERD relationships, see page \pageref{fig:ERD_relationship}).
This graphical element is the logical center and connection point for all arrows and lines from and to elements participating in this relationship.



\vspace{4mm}
\noindent
\textbf{Solution to problem 2: Categorization by coloring}
\vspace{1mm}

\noindent
To counter the second major problem of the graphical EL notation used by \cite{Amthor18} we need a better way to depict category memberships.
Unfortunately -- as already mentioned above -- falsely classified elements are unavoidable with the method of horizontally aligning elements.
Expanding the method into two dimensions will not solve this issue either, because it does not change the situation of falsely associated elements with horizontally (or vertically) aligned categories.
Therefore aligning elements to one (or two) axis is not suitable for this task of classification.

As described in section \ref{gestalt_laws} \textit{gestalt laws} can help to solve graphical-based tasks.
The method of classifying by horizontally aligning elements utilizes the \textit{law of proximity}, but due to elements being potentially widely distributed the \textit{law of similarity} seems more suitable for this instead.
The law says that objects can be logically grouped, although they may not be in close range to each other, with the help of \textit{gestalt factors}.
The gestalt factor \textit{shape} is already occupied for depicting an elements type, \textit{brightness} may be too subtle, \textit{size} impractical, \textit{orientation} and \textit{rotation} not applicable to circles or arrows with fixed start and end points.
But \textit{color} seems to be a suitable solution.
Coloring can indicate an element's classification without proximity, aligning or altering its shape and is applicable to sets (circles, ellipses) as well as to relationships (arrows, lines).
Also multiple category memberships can be depicted by multi-coloring the enclosed area of circles or the lines of arrows.




\section{Structure and Elements}
\label{gsl_elements}
The core structure of the notation is adopted from \cite{Amthor18} and is extended with the solutions proposed above.
Depicting categories by horizontal spaces indicated with dotted lines at the bottom of the diagram is removed and is replaced with coloring.

\subsection{Sets}
Regarding their shape sets remain the same, but now have colored areas to indicate category memberships.
The depiction of subsets is unaltered as well: They are drawn as smaller circles inside their supersets.
They can be colored individually to their superset.

The internal definition of sets (equations like $P = 2^{O \times OP}$ in $RBAC_0$, see definition \ref{definition:RBAC}) on page \pageref{definition:RBAC}) is not depicted in a graphical way for the same reasons as for the usage of a mathematical expression for annotations and mathematical symbols for argument operation types.
Still set definitions can be depicted with a mathematical expression inside the set itself.



\subsection{Relationships}
Simple one-headed arrows depict mappings, double-headed arrows depict relations, unchanged.
Unlike its origin notation they can now indicate not just its relationship type (mapping, relation), but also the type of operation that describes how its arguments are connected.


% Example Amthor vs example coloring

% Example multi-coloring set, example arrow




\section{Visualization on a Higher Level of Abstraction}
\label{higher_abstraction_level}



\section{Summary}
\label{gsl_summary}
% essential: find interfaces/break points where graphical and where mathematical expression is reasonable




\cleardoublepage
\chapter{Design: Editor GUI}
\label{editor_design}
% ein/ausblendbar, Übersicht, "layer"

\section{Structure}
\label{editor_structure}


\section{Sections}
\label{editor_sections}




\cleardoublepage
\chapter{Implementation}
\label{implementation}
	
	
\section{Implementation Base}
\label{implementation_base}
Qt, MVC

\section{Structure}
\label{implementation_structure}
	
	
\section{GUI sections}
\label{implementation_sections}




\cleardoublepage
\chapter{Evaluation}
\label{evaluation}


\section{Graphical Specification Language}
\label{evaluation_gsl}


\section{Editor}
\label{evaluation_editor}


\cleardoublepage
\chapter{Conclusion}
\label{conclusion}
\blindtext



\cleardoublepage
\chapter{Summary}
\label{summary}
\blindtext



% Anhang
%\cleardoublepage
%\tocentry{Anhang}
%\renewcommand{\thesection}{\Alph{section}}
%\markboth{Anhang}{}
%\chapter*{Anhang}
%\section{Kapitel 1}
%\section{Kapitel 2}
%\label{appendix}




% Literaturverzeichnis
\cleardoublepage
\DeclareRobustCommand{\citeext}[1]{\citeauthor{#1}~\cite{#1}}
\bibliographystyle{plainnat}

\bibliography{other/db}

\tocentry{Bibliography}





\end{document}